/*
 * generated by Xtext
 */
package ufscar.compiladores2.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IFileSystemAccess
import org.eclipse.xtext.generator.IGenerator
import ufscar.compiladores2.musy.Midi
import ufscar.compiladores2.musy.TrackBody
import ufscar.compiladores2.musy.Track
import ufscar.compiladores2.musy.TimeSignature
import ufscar.compiladores2.musy.Parameter
import ufscar.compiladores2.musy.Note
import ufscar.compiladores2.musy.Block
import ufscar.compiladores2.musy.DeclaredChord
import ufscar.compiladores2.musy.Interval
import ufscar.compiladores2.musy.Triplet

//TODO: consertar o octave quando o parametro nao é passado

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MusyGenerator implements IGenerator {
	
	int BPM;
	int sigNumerator;
	int sigDenominator;
	double timePause;
	double timeNote;
	int octave;
	double relativeTick = 0.0;
	
	
	//Add parameter variables, change them during compile
	
	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
		fsa.generateFile(resource.allContents.filter(typeof(Midi)).toList.get(0).name.toLowerCase +'.py', 
			resource.allContents
				.filter(typeof(Midi)).toList.get(0).compile)
	}
	
	def getInitInfo(Midi m) {
		for(Parameter p : m.body.params.toList) {
			if(p.po != null) {
				octave = p.po.octave;
			}
			else if(p.pb != null) {
				BPM = p.pb.beat;
			}
			else if(p.pts != null) {
				sigNumerator = p.pts.tsig.quantity;
				sigDenominator = p.pts.tsig.note;
			}
			else if(p.ptn != null) {
				timeNote = timeMap(p.ptn.tn);
			}
			else if(p.ptp != null) {
				timePause = timeMap(p.ptp.tp);
			}
			
		}
	}
	
	def timeMap(String s) {
		if(s.equals("sb")) {
			return 4;
		}
		else if(s.equals("m")) {
			return 2;
		}
		else if(s.equals("sm")) {
			return 1;
		}
		else if(s.equals("cl")) {
			return 0.5;
		}
		else if(s.equals("sc")) {
			return 0.25;
		}
		else if(s.equals("f")) {
			return 0.125;
		}
		else if(s.equals("sf")) {
			return 0.0625;
		}
	}
	
	def dotMap(String s) {
		if(s.equals(".")) {
			return 1.5;
		}
		else if(s. equals("..")) {
			return 1.75;
		}
		else if(s.equals("...")) {
			return 1.875;
		}
	}
	
	def getNInstrument(Track t) {
		if(t.i.equals("PIANO")) {
			return 1;
		}
		else if(t.i.equals("GUITAR")) {
			return 25;
		}
		else if(t.i.equals("ELECTRIC GUITAR")) {
			return 31;
		}
		else if(t.i.equals("BASS")) {
			return 34;
		}
		else if(t.i.equals("SAX")) {
			return 65;
		}
		else if(t.i.equals("VIOLIN")) {
			return 41;
		}
		else if(t.i.equals("DRUMS")) {
			return 15;
		}
		else if(t.i.equals("STRINGS")) {
			return 51;
		}
	}
	
	def getTimeNote(Note n) {
		if(n.cnp != null && n.cnp.duration != null) {
			if(n.cnp.dots != null) {
				return dotMap(n.cnp.dots) * timeMap(n.cnp.duration);
			}
			return timeMap(n.cnp.duration);
		}
		else return timeNote;
	}
	
	def getNoteName(Note n) {
		if(n.acc != null) {
			if(n.acc.equals("#")) {
				return n.nl + "s";
			}
			else {
				switch n.nl {
					case "C": "B"
					case "D": "Cs"
					case "E": "Ds"
					case "F": "E"
					case "G": "Fs"
					case "A": "Gs"
					case "B": "As"
				}
			}
		}
		else return n.nl;
	}
	
	def getNoteOctave(Note n) {
		// && n.ncp.octave is defined
		if(n.cnp != null) {
			return n.cnp.octave;
		}
		else return this.octave;
	}
	
	def getStartTick() {
		var double relative = relativeTick.doubleValue;
		relativeTick = 0.0;
		return relative;
	}
	
	def calculateEndTick(Note n) {
		return 220 * getTimeNote(n);
	}
	
	def void putPause(Interval i) {
		if(i.tempo != null) {
			relativeTick = (relativeTick + 220 * timeMap(i.tempo));
		}
		else relativeTick = (relativeTick + 220 * timePause);	
	}
	
	def compile(Midi m) '''
	«getInitInfo(m)»
	import midi
	
	«m.name»_MIDI = midi.Pattern(
		tracks=[
	«FOR track:m.body.tracks.toList SEPARATOR ','»
		«track.compile»
	«ENDFOR»
		]
	) 
	
	midi.write_midifile("«m.name.toLowerCase».mid", «m.name»_MIDI)
	'''
	
	def compile(Track t) '''
		[	midi.TimeSignatureEvent(tick=0, data=[«sigNumerator», «(Math.log(sigDenominator) / Math.log(2)) as int», 24, 8]),
			midi.KeySignatureEvent(tick=0, data=[0, 0]),
			midi.SetTempoEvent(tick=0, bpm=«this.BPM»),
			midi.EndOfTrackEvent(tick=1, data=[])],
		[ midi.ControlChangeEvent(tick=0, channel=0, data=[91, 58]),
			midi.ControlChangeEvent(tick=0, channel=0, data=[10, 69]),
			midi.ControlChangeEvent(tick=0, channel=0, data=[0, 0]),
			midi.ControlChangeEvent(tick=0, channel=0, data=[32, 0]),
			midi.ProgramChangeEvent(tick=0, channel=0, data=[«t.getNInstrument»]),
			«t.tbody.compile»
		]
	'''
	
	def String compile(TrackBody tb) {
		var String retorno = "";
		var int len = tb.bc.toList.size;
		var int i = 0;
		for(bComponent : tb.bc.toList) {
			if(bComponent.note != null) {
				retorno += bComponent.note.compile;
			}
			else if(bComponent.block != null) {
				retorno += bComponent.block.compile;
			}
			else if(bComponent.dc != null) {
				retorno += bComponent.dc.compile;
			}
			else if(bComponent.interval != null) {
				bComponent.interval.putPause;
			}
			else if(bComponent.trip != null) {
				retorno += bComponent.trip.compile;
			}
			else if(bComponent.blckRef != null) {
				retorno += bComponent.blckRef.compile;
			}
			i += 1;
			if(i < len && bComponent.interval == null) {
				retorno += ","
			}
		}
		return retorno;
	}
	
	//intervalo nao pode separar por virgula
//	def compile(TrackBody tb) '''
//	«FOR bComponent:tb.bc.toList SEPARATOR ','»
//		«IF bComponent.note != null»
//			«bComponent.note.compile»
//		«ELSEIF bComponent.block != null»
//			«bComponent.block.compile»
//		«ELSEIF bComponent.dc != null»
//			«bComponent.dc.compile»
//		«ELSEIF bComponent.interval != null»
//			«bComponent.interval.putPause»
//		«ELSEIF bComponent.trip != null»
//			«bComponent.trip.compile»
//		«ELSEIF bComponent.blckRef != null»
//			«bComponent.blckRef.compile»
//		«ENDIF»
//	«ENDFOR»
//	'''
	
	def compile(Note n) '''
		midi.NoteOnEvent(tick=«getStartTick as int», velocity=80, pitch=midi.«n.noteName»_«n.noteOctave»),
		midi.NoteOffEvent(tick=«n.calculateEndTick as int», pitch=midi.«n.noteName»_«n.noteOctave»)
	'''
	
	def compile(Block b)'''
	«b.blockbody.compile»
	'''
	
	def compile(DeclaredChord dc) '''
	«FOR chordNote:dc.cp.cnote.toList»
		midi.NoteOnEvent(tick=«getStartTick as int», velocity=80, pitch=midi.«chordNote.noteName»_«chordNote.noteOctave»),
	«ENDFOR»
	midi.NoteOffEvent(tick=«dc.cp.cnote.toList.get(0).calculateEndTick as int», pitch=midi.«dc.cp.cnote.toList.get(0).noteName»_«dc.cp.cnote.toList.get(0).noteOctave»),
	«FOR i: 1..dc.cp.cnote.toList.size - 1 SEPARATOR ','»
		midi.NoteOffEvent(tick=0, pitch=midi.«dc.cp.cnote.toList.get(i).noteName»_«dc.cp.cnote.toList.get(i).noteOctave»)
	«ENDFOR»
	'''
	
	def compile(Triplet t) '''
		midi.NoteOnEvent(tick=«getStartTick as int», velocity=80, pitch=midi.«t.n1.noteName»_«t.n1.noteOctave»),
		midi.NoteOffEvent(tick=«((t.n1.calculateEndTick * 2) / 3) as int», pitch=midi.«t.n1.noteName»_«t.n1.noteOctave»),
		midi.NoteOnEvent(tick=«getStartTick as int», velocity=80, pitch=midi.«t.n2.noteName»_«t.n2.noteOctave»),
		midi.NoteOffEvent(tick=«((t.n2.calculateEndTick * 2) / 3) as int», pitch=midi.«t.n2.noteName»_«t.n2.noteOctave»),
		midi.NoteOnEvent(tick=«getStartTick as int», velocity=80, pitch=midi.«t.n3.noteName»_«t.n3.noteOctave»),
		midi.NoteOffEvent(tick=«((t.n3.calculateEndTick * 2) / 3) as int», pitch=midi.«t.n3.noteName»_«t.n3.noteOctave»)
	'''
}
